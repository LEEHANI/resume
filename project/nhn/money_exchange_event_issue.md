## 이벤트 개발
더블에이 포커를 신규 런칭하면서 모바일 포커와 머니 교환할 수 있는 이벤트를 맡게 됐다.
더블에이 포커, 모바일 포커가 양방향으로 머니를 교환할 수 있는 이벤트였고, 게임 중에는 교환할 수 없다는 기획이 있었다.


## 코드 리뷰 
팀원이 더블에이 포커의 출금 & 입금 API를 개발을 완료하고 PR을 올렸다. 리뷰하다보니 크게 두 가지 문제점이 눈에 띄었다.
첫 번째로 비관적락 기법을 써서 동시성 이슈를 피하도록 구현했다. 머니 교환 중일 때는 회원이 게임 중이 아니니 회원 테이블을 조회할 일이 없을지라도, 회원 테이블에 비관적락을 거는 건 다른 장애 상황을 유발할 거라는 판단이 들었다.

두 번째로 @Transactional 내부에서 외부 API 호출을 수행하고 있었다. 그렇게 되면 DB 커넥션 부족으로 이어질 수 있고, 최악의 경우 내 서비스에 톰캣 스레드 수가 부족해져 장애가 발생할 수 있기 때문에 주의해서 개발해야 한다.

리뷰하면서, 개발을 처음부터 다시 해야 할 수도 있겠다는 생각이 들었다. 리뷰한 걸 팀장님이 보시고는 모바일 포커 개발은 내가 맡는 게 좋겠다고 했다. 나는 모바일 포커에서 출금 & 입금 API를 맡게 됐다.  


## 어떤 락을 써야 하지?
이번 개발에서 동시성 처리에 대한 초점을 맞추어 개발했다. 동시에 여러 번을 호출하여 머니 교환을 시도한 경우 한 번만 수행해야 했다. 

동시성 이슈를 막기 위해 처음 든 생각은, JPA를 사용하고 있으니 @Version을 사용한 낙관적 락을 사용할 수 있겠다는 생각이 들었었다. 근데, 변경 대상이 되는 머니 컬럼이 회원 테이블에 있었다. 이번 이벤트를 위해 회원 테이블에 버저닝 컬럼을 새로 추가하는 건 맞지 않다고 생각했다. 그래서 redis를 이용해 분산락을 쓰기로 결정했다. 


## 작업의 순서가 중요해.
머니 교환 요청이 들어오면 제일 먼저 회원 id를 키로 락을 걸었다. redis 키는 대략 MPOKER_MONEY_EXCHANGE:MEMBER:ID로 설계했고, 겹치지 않게 주의했다. 락을 걸 때는 setIfAbsent를 사용하여 원자성에 유의했다. 이미 기존에 락이 있으면 머니 교환이 진행 중이므로 예외를 발생시켰다.
락을 걸고 회원 인증, 게임 중인지 체크하기 위해 외부 API를 호출하여 정상적인 회원이 게임을 안 하고 있는지 확인했다. 
그 후 출금 가능한지 validation을 체크하여 머니 교환할 준비가 된 회원인지 확인했다. 
모든 준비가 완료되면 머니 출금, 로그 적재를 수행하고 락을 해제했다. 
내부적으로 kafka를 사용하고 있지 않아서, 모바일 포커의 머니 출금이 완료되면 더블에이 포커에 입금 요청 API를 호출했다. API 호출 실패를 대비해 n번 retry를 시도했고, 그런데도 실패하게 되면 실패 로그를 남기고 차감한 머니를 원복하도록 보정 작업을 구현했다.


## 회고 
이번에 이벤트 업무 작업하면서 일정을 널널하게 잡았음에도 예상보다 시간이 부족했다는 팀원의 피드백이 있었다. 팀원들에게 시간이 왜 부족했는지 얘기해 보자고 제안했고, 이유를 곰곰히 생각해 보니 코드 리뷰를 통해서 코드 전체적으로 수정해야 할 부분이 많았다. 수정할 건 많은데 코드 반영할 시간은 짧아서 촉박하게 일이 진행되어야 했다. 사전에 디자인 설계를 공유했더라면, 코드 수정이 적어지고 이슈가 될만한 상황도 더 빨리 캐치할 수 있을 거라는 얘기가 오갔다. 전에는 팀 내 디자인 리뷰를 하는 시간이 없었지만, 다음에는 이런 여러 이슈가 발생할 만한 작업을 진행할 때, 미리 어떤 식으로 개발할지 미팅하는 시간을 갖기로 했다. 
