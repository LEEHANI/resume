## 포커 어드민 개발… 간헐적으로 재시작?
팀원이 퇴사하고 포커 어드민 프로젝트의 오너가 됐다.
퇴사자가 전해준 인계인수 중의 하나는 간헐적으로 포커 어드민 리얼 서버를 재시작해야 한다고 했다. 이유는 모르겠지만 간헐적으로 503 에러를 띄우며 서버가 자꾸 먹통이 되고 있고, 본인도 그렇게 인수인계를 받았다고 했다. 추측하기론 2년 전부터 이런 현상이 지속되었고 해결이 어려워서 간헐적으로 재시작을 해주고 있다고 했다.

프로젝트를 맡게 된지 얼마 안 돼서 포커 어드민이 죽었으니, 서버를 재시작해달라는 기획자의 요청을 받았다.
히스토리 파악을 위해 기획자와 얘기해 본 결과, 2020년도부터 발생하고 있었고 다량의 데이터를 조회 혹은 다운로드할 때 발생하는 것으로 보인다는 개인적인 추측만 있다고 전달받았다. 

## 원인이 뭐지?
사내 서버 모니터링 시스템 NSight에서 CPU 지표를 봤었지만, 별다른 특이 사항은 없었다. 이슈 전에 어떤 상황이었는지 궁금하여 그 당시 로그를 찾아봤지만, 리얼 로그에는 DB 쿼리 로그만 남기고 있었다.
분석하기에는 자료가 부족하여 다음 배포 때 request (로깅) 필터를 추가했고, 메모리에 문제가 있을 수 있어서 OOM 발생 시 heap dump 생성하도록 JVM 옵션을 추가했다. 

배포가 나가고, 틈틈이 모니터링을 진행했다. 간헐적으로 OOM 가 발생했고, 특정 API 사용 시 메모리 사용량이 많아지는 현상이 있었다. 어느 정도 패턴을 파악해 보니, 서버가 먹통 되기 전에 게임 로그 조회 API를 조회하는 경우가 많았고, API 응답이 서서히 느려지면서 OOM이 여러 번 발생했다. 그 점을 보고 힙 메모리를 늘리면 이슈 발생 빈도가 낮아질 수 있겠다는 생각이 들었다. 그러나 해당 서버의 메모리 여유 공간이 없었고, 비용적인 문제로 메모리 확보가 어려웠다. 그래서 보다 근본적인 해결 방법을 찾기 위해 힙 덤프와 소스 코드를 분석했다. 

## heap dump
mat으로 힙 덤프를 분석해 보니 problem suspect가 크게 세 군데가 있었고, 그중 두 개가 연관되어 보였다. 첫 번째는 “com.mysql.jdbc.JDBC4ResultSet” 으로 mysql에서 조회해 온 결과를 “com.mysql.jdbc.ByteArrayRow” 객체에 담는데 메모리의 18%가 사용되고 있었다.  두 번째는 첫 번째에서 디비 조회 결과가 담긴 ByteArrayRow 객체를 내가 만든 DTO 객체에 바인딩하는 과정에서 사용되는 메모리였다. 이 과정에 메모리가 전체의 34%가 사용됐는데, ByteArrayRow의 조회 결과 개수와 DTO에 바인딩하는 개수가 맞지 않은 거로 봐서는 바인딩에 전부 성공하지 못하고 OOM이 발생한 걸로 파악됐다. 정리해 보면, 디비 결과를 바로 DTO에 바인딩하는 게 아니라 ByteArrayRow에 담은 후 바인딩해 주기 때문에 실제로는 더 많은 메모리가 필요했다. 디비에서 왜 이렇게 조회를 많이 해와야 하지? API 성능이 느린 것도 데이터가 많아서인가? 이런저런 의문이 들었고 소스 코드를 보게 됐다. 


## Mybatis에서 n+1 문제
로컬에서 게임 로그 조회 API에 대해 분석했다. 특정 회원이 게임 했던 기록을 조회하고 그 회원과 같이 게임을 했던 상대편 목록도 조회해 왔다. 게임 기록 조회 시 로그를 자세히 살펴보니 N+1 문제가 발생하고 있었다. 먼저 회원 1에 대한 게임 기록을 조회해 오고, 회원 1과 게임을 했던 상대편을 N 번 조회하는 쿼리가 발생하고 있었다. 만약 회원 1이 100번의 게임을 했다면 101번의 쿼리가 발생하게 된다. MyBatis를 사용해 조회를 해오고 있었는데, 상대편을 ResultMap에 Nested Select로 조회해 오고 있어서 N+1 문제가 발생한 이유였다. Nested Select 부분을 제거하고 상대편을 in 절로 조회하도록 쿼리를 개선했다. 2번의 쿼리로 게임 기록 조회를 할 수 있게 됐다. 


## 또 다른 문제점 발견 ?!
개선된 쿼리를 explain으로 인덱스를 적절히 사용 중인지 확인해 봤다. partitions 컬럼을 보니 파티션 항목에 여러 조건이 잡혔다. 게임 로그 테이블은 날짜 컬럼을 기준으로 하루씩 파티션을 나눠서 저장하고 있었는데, 게임 로그 조회 쿼리는 full partition search로 탐색하고 있었다. 이에 따라 API 성능이 더 안 좋아지고 있다는 판단이 들었고, 특정 파티션만 탐색할 수 있게 조회 조건에 파티션 키를 추가했다. 다행히 파티션 키는 화면에서 파라미터로 입력받고 있는 칼럼이었고, 쿼리를 개선한 후에 explain으로 특정 파티션만 탐색하고 있는지 확인했다. 


## 페이지는?
상대편을 in절로 조회하는 쿼리로 개선하고 생각해 보니 1000명 이상일 때, 조회가 정상적으로 되지 않을 거라는 생각이 들었다. 그리고 여전히 한 번에 너무 많은 조회를 하게 되면 또다시 heap이 터질 위험이 다분했다. 게임 로그 조회에 페이징 처리가 필요한 상황이었다. 기획자에게 서버에 메모리 이슈가 발생하고 있으니 페이징 기능을 넣자고 제안했다. 기획자는 페이징을 넣게 되면 클린 파트에서 기존과 달리 스크롤로 기록을 한 번에 볼 수 없으니 불편하다는 얘기를 전달했고, 페이징 기능에 대해서는 나중에 다시 얘기해 보자는 답변을 줬다. 개발자 입장에서 페이징이 무조건 필요하기 때문에, 그러면 일반적인 페이징 대신에 스크롤을 할 수 있게 더 보기 버튼을 눌러서 기존 기록에 append 되는 방식으로 끊어서 조회하는 방식으로 다시 제안했다. 그 방식이면 클린 파트에서도 괜찮을 것 같다며 확인받고 페이징까지 추가할 수 있게 됐다.


## 결과적으로
위 3개의 개선 작업으로, 게임 로그 조회 API 성능을 기존보다 2000% 향상시켰다. 더 이상 OOM 이슈가 발생하지 않았고, 포커 어드민 재시작 요청은 현재까지 오지 않고 있다. 
| 조회 개수 | AS-IS (ms) | TO-BE (ms) | 개선 수치 |
|-----------|------------|------------|------------|
| 139       | 1031       | 42         | 2354%      |
| 212       | 1346       | 73         | 1743%      |
| 505       | 3688       | 140        | 2534%      |
| 975       | 6959       | 300        | 2219%      |
| 1230      | 8655       | 393        | 2102%      |
| 1679      | 11557      | 604        | 1813%      |
| 11537     | 130981     | 3720       | 3420%      |


## 회고 
이번 이슈를 해결하면서 느낀 건, 개발 당시에는 드러나지 않았던 잠재적 버그 코드들이 뒤늦게 발견되었을 때 해결이 훨씬 어렵다는 것을 깨달았다. 그나마 지금처럼 어떻게든 단서를 찾을 수 있다면 해결할 수 있겠지만, 문제가 되는 여러 코드가 얽혀서 문제가 발생하고 있었다면 해결이 훨씬 어려웠을 것이다. 예를 들면, 100개의 코드에서 메모리 사용량이 균등하게 높아서 어느 하나를 수정하더라도 해결될 수 없는 상황이라면.. 생각만 해도 끔찍..
따라서 나는 앞으로 개발할 때, 미래에 문제를 야기할 수 있는 수준의 코드인지에 대해서 조금 더 깊게 생각하고 있고, 동료 개발자분들의 코드를 리뷰할 때도 지금 당장의 코드의 동작이 아니라 나중에도 문제가 되진 않을지에 대해서 질문을 던지는 방식을 취하고 있다.

이번에 해결한 포커 어드민 이슈는 OOM, heap 분석, MyBatis에서 N+1 문제, full partition search 등 여러 기술적인 이슈가 많았다. 평상시 개발에서는 접하기 어려운 상황이라 다른 분들에게 기술 공유를 하면 괜찮겠다는 생각이 들었다. 그동안 해왔던 일들을 글로 정리하여 사내 발표를 진행했고, 많은 분이 흥미롭게 들었다. 특히 이사님은 서버 재시작 문제가 있다는 것을 알고 계셨는데, 문제의 원인을 알게 되어 매우 기뻐하셨다.
위 발표로 인해 좋은 평가를 받게 되었고, 우수 사원으로 선발되었다.